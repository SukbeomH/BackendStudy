# BE Day31 마이크로 서비스 / NginX

**목차**

  

---

# 마이크로 서비스

우리가 지금까지 개발해왔던 서비스는 여러 작고 중요한 모듈들이 합쳐진 하나의 거대한 프로젝트입니다. 로그인, 파일 업로드, 결제 등 필요한 역할별로 개발을 하고, 개발이 완료되면 하나로 묶어서 배포했었습니다. 이런 방식을 `모놀리식 아키텍처(Monolithic Architecture)`라고 부릅니다. 

![[https://www.nginx.com/blog/introduction-to-microservices/](https://www.nginx.com/blog/introduction-to-microservices/)](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/Untitled.png)

[https://www.nginx.com/blog/introduction-to-microservices/](https://www.nginx.com/blog/introduction-to-microservices/)

이렇게 하면, 하나의 프로젝트를 개발하고 테스트하고 빌드하기 때문에 단순합니다. 하지만, 여러 모듈들이 함께 있기 때문에 작은 부분에 문제가 생겨도 다른 부분에 영향을 줍니다. 예를 들어 파일 업로드 기능 때문에 서버에 문제가 생겼는데, 이로 인해 로그인도 안되고, 모든 기능이 엉켜버리는 문제가 발생할 수 있습니다. 

서비스가 점점 커질경우 하나의 프로젝트로 함께 묶는것이 점점 버거워지고 복잡해지게 됩니다. 이를 해결하기 위해 나온 것이 `마이크로서비스 아키텍처`입니다. 

![[https://www.nginx.com/blog/introduction-to-microservices/](https://www.nginx.com/blog/introduction-to-microservices/)](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/Untitled%201.png)

[https://www.nginx.com/blog/introduction-to-microservices/](https://www.nginx.com/blog/introduction-to-microservices/)

이름에서 알 수 있듯이 한 프로젝트를 여러 작은 서비스로 분해하여 개발하고 운영하고 배포하는 방법입니다. 여러 모듈로 분리했기 때문에 팀별로 독립적으로 개발할 수 있게 됩니다. 

우리 프로젝트에 적용해보면 아래와 같은 파이프라인이 그려질 수 있습니다. 

인증/인가를 담당하는 auth API를 따로 분리하고, 나머지 부분을 resource 라고 부릅니다.

여기서 resource 부분을 더 세부적으로 분리할 수 있겠지만, 일단 크게 두개로만 분리하겠습니다. 

![Untitled](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/Untitled%202.png)

---

# Nest기반 Rest-API의 마이크로서비스 분리

`Nest.js`에서 지원하는 `@nestjs/microservices`를 사용해서 **auth**와 **resouce**라는 각각 Rest-API로 이루어진 Nest 프로젝트를 분리해보겠습니다.

## services

`33-01-msa-rest` 폴더 밑에 services 폴더를 만들어주세요.

### auth

터미널을 열어 `33-01-msa-rest` 폴더로 이동합니다. 새로운 Nest 프로젝트를 만들겠습니다. 

`nest new auth`를 입력합니다. 

<aside>
⚠️ nest 명령어가 안된다면, `npm i -g @nestjs/cli` 를 해주세요! 
맥의 경우 `sudo npm i -g @nestjs/cli`

</aside>

![Untitled](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/Untitled%203.png)

yarn을 선택합니다. 

`src` 폴더를 수정하겠습니다. 

먼저 불필요한 파일을 삭제합니다. (app.controller.spec.ts)

아래와 같은 모습이 됩니다.

![Untitled](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/Untitled%204.png)

터미널을 열어 **auth** 폴더로 이동합니다. 

`yarn add @nestjs/microservices` 를 입력해 설치합니다.

![Untitled](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/Untitled%205.png)

먼저 `main.ts` 파일에서 앱모듈을 **create**가 아닌 **createMicroservice**를 해줍니다.

첫번째 값으로 네트워크 전송 계층을 정합니다. 

`transport: Transport.TCP` → 마이크로서비스는 기본적으로 TCP 레이어를 사용합니다. 

두번째로 호스트 이름과 포트를 정해줍니다. 

```tsx
// main.ts

import { NestFactory } from '@nestjs/core';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.createMicroservice<MicroserviceOptions>(
    AppModule,
    { transport: Transport.TCP, options: { host: 'auth-service', port: 3001 } },
  );
  await app.listen();
}
bootstrap();
```

두개의 서비스(auth와 resource)를 분배해주는 게이트웨이의 포트를 3000으로 하고, auth는 `3001`, resource는 3002로 하겠습니다. 

`app.controller.ts` 파일에 **login** API를 만들어줍니다. 

```tsx
// app.controller.ts

import { Controller } from '@nestjs/common';
import { AppService } from './app.service';
import { MessagePattern } from '@nestjs/microservices';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @MessagePattern({ cmd: 'login' })
  login(): string {
    return 'login을 요청하셨습니다!';
  }
}
```

이상한게 있다면 **@Get**이나 **@Post** 같은 Rest-API의 Method를 적는게 아니라 `@MessagePattern`을 적어주었습니다. 

이 메세지 패턴을 통해 게이트웨이에서 각각의 API로 요청을 전달합니다. 

---

### resource

이제 `auth` 폴더를 복사 붙여넣기 해 사본을 만들고, `resource`로 이름을 변경해주세요. 

`main.ts` 파일을 수정합니다. 

```tsx
import { NestFactory } from '@nestjs/core';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.createMicroservice<MicroserviceOptions>(
    AppModule,
    { transport: Transport.TCP, options: { host: 'resource-service', port: 3002 } },
  );
  await app.listen();
}
bootstrap();
```

 `3002`로 포트를 수정하고, 호스트 이름을 `resource-service`로 변경합니다. 

`app.controller.ts` 파일을 수정합니다. 

```tsx
import { Controller, Get } from '@nestjs/common';
import { MessagePattern } from '@nestjs/microservices';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @MessagePattern({ cmd: 'fetchBoards' })
  fetchBoards(): string {
    return 'fetchBoards를 요청하셨습니다!';
  }
}
```

login API를 지우고, `fetchBoards` API를 작성합니다. 

마찬가지로 **MessagePattern** 데코레이터를 사용합니다. 

---

## api-gateway

이제 두개의 Rest-API 를 만들었으니 이를 관리해줄 게이트웨이를 만들어보겠습니다.

`msa-01-rest` 폴더에 **api-gateway** 폴더를 만들고 **auth** 폴더의 내용을 복사 붙여넣기 합니다.

`app.service.ts` 파일은 삭제합니다. 

![Untitled](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/Untitled%206.png)

`main.ts` 파일은 처음 Nest 프로젝트의 설정과 같이 고쳐줍니다. 

```tsx
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.listen(3000);
}
bootstrap();
```

`app.module.ts` 파일을 수정합니다. 

```tsx
import { Module } from '@nestjs/common';
import { ClientsModule, Transport } from '@nestjs/microservices';
import { AppController } from './app.controller';
// import { AppService } from './app.service';

@Module({
  imports: [
    ClientsModule.register([
      {
        name: 'AUTH_SERVICE',
        transport: Transport.TCP,
        options: { host: 'auth-service', port: 3001 },
      },
      {
        name: 'RESOURCE_SERVICE',
        transport: Transport.TCP,
        options: { host: 'resource-service', port: 3002 },
      },
    ]),
  ],
  controllers: [AppController],
  // providers: [AppService],
})
export class AppModule {}
```

`AppService`는 사용하지 않으니 주석 처리합니다. 

앞서 우리는 auth와 resource를 만들었습니다. 그에 맞게 `ClientsModule`을 만들어줍니다.

`app.controller.ts` 파일에서 

컨트롤러에서 서비스(**clientAuthService**)를 **주입**시키고, 구체적인 엔드포인트별로 어느 서비스로 가야할지 지정해줍니다.

```tsx
import { Controller, Get, Inject } from '@nestjs/common';
import { ClientProxy } from '@nestjs/microservices';
import { Observable } from 'rxjs';

@Controller()
export class AppController {
  constructor(
    @Inject('AUTH_SERVICE') private readonly clientAuthService: ClientProxy,
    @Inject('RESOURCE_SERVICE')
    private readonly clientResourceService: ClientProxy,
  ) {}

  @Get('/auth/login')
  login(): Observable<string> {
    return this.clientAuthService.send({ cmd: 'login' }, {});
  }

  @Get('/resource/boards')
  fetchBoards(): Observable<string> {
    return this.clientResourceService.send({ cmd: 'fetchBoards' }, {});
  }
}
```

`cmd` 는 앞서 API에서 작성했던 메세지 패턴을 적습니다. 

API에 넘겨줄 값이 있다면 두번째 인자로 정할 수 있습니다. 지금은 없기 때문에 빈 객체`{}`를 적었습니다. 

`Observable` 타입 설정을 위해

터미널에서 **api-gateway** 폴더로 이동해  `rxjs` 를 설치해줍니다. 

![Untitled](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/Untitled%207.png)

최종적으로 우리는 3개의 프로젝트를 갖게 되었습니다. 

- api-gateway
- auth
- resource

![Untitled](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/Untitled%208.png)

이제 이 3개의 서버를 띄우기 위해

 `33-01-msa-rest` 폴더에  `docker-compose.yaml` 파일을 만들어줍니다. 

`Dockerfile` 은 각 서비스마다 하위에 넣어줍니다.

![Untitled](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/Untitled%209.png)

api-gateway >  `Dockerfile`

```docker
FROM node:16

WORKDIR /api-gateway/
COPY ./package.json /api-gateway/
COPY ./yarn.lock /api-gateway/
RUN yarn install

COPY . /api-gateway/
CMD yarn start:dev
```

auth >  `Dockerfile`

```docker
FROM node:16

WORKDIR /auth-service/
COPY ./package.json /auth-service/
COPY ./yarn.lock /auth-service/
RUN yarn install

COPY . /auth-service/
CMD yarn start:dev
```

auth >  `Dockerfile`

```docker
FROM node:16

WORKDIR /resource-service/
COPY ./package.json /resource-service/
COPY ./yarn.lock /resource-service/
RUN yarn install

COPY . /resource-service/
CMD yarn start:dev
```

`.dockerignore` 마찬가지로 폴더마다 넣어줍니다.

```tsx
dist
node_modules
```

`docker-compose.yaml` 파일

```yaml
version: "3.3"

services:
  api-gateway:
    build:
      context: ./api-gateway
      dockerfile: Dockerfile
    volumes:
      - ./api-gateway/src:/api-gateway/src
    ports:
      - 3000:3000

  auth-service:
    build:
      context: ./services/auth
      dockerfile: Dockerfile
    volumes:
      - ./services/auth/src:/auth-service/src
    ports:
      - 3001:3001

  resource-service:
    build:
      context: ./services/resource
      dockerfile: Dockerfile
    volumes:
      - ./services/resource/src:/resource-service/src
    ports:
      - 3002:3002
```

host 이름 정해준 것과 같이 도커 서비스의 이름을 정합니다.

`docker-compose build`

`docker-compose up` 을 차례대로 입력해 서버를 띄웁니다.

![Untitled](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/Untitled%2010.png)

**postman**으로 확인해봅니다. ✨

![Untitled](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/Untitled%2011.png)

![Untitled](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/Untitled%2012.png)

---

# Nest기반 GQL-API의 마이크로서비스 분리

이번에는 Nest에서 그래프큐엘로 이루어진 API를 마이크로서비스로 분리해보겠습니다. 

`33-01-msa-rest` 폴더를 복사해 `33-02-msa-graphql` 폴더를 새로 만들어주세요.

### auth

터미널에서 **auth** 폴더로 이동해 `@nestjs/graphql` 와 `graphql` , `apollo-server-express`을 설치합니다. 

`app.controller.ts` 파일은 삭제합니다. 

먼저 **services** > **auth** 폴더의 `main.ts` 파일을 수정합니다.

```tsx
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3001);
}
bootstrap();
```

3001번 포트로 기본 Nest 앱을 생성합니다.

`app.resolver.ts` 파일을 새로 만들어줍니다. 

```tsx
import { Mutation, Resolver } from '@nestjs/graphql';
import { AppService } from './app.service';

@Resolver()
export class AppResolver {
  constructor(private readonly appService: AppService) {}

  @Mutation(() => String)
  login(): string {
    return 'login을 요청하셨습니다.';
  }
}
```

login API를 만들었습니다. 

`app.module.ts` 파일을 수정해 GraphQLModule을 추가합니다.

Nest에서 그래프큐엘을 마이크로서비스로 분리하기 위해 **[Federation](https://docs.nestjs.com/graphql/federation)**을 사용합니다. 

`ApolloFederationDriver`를 사용하기위해 **@nestjs/apollo과 @apollo/subgraph**를 설치합니다. 

```tsx
import {
  ApolloFederationDriver,
  ApolloFederationDriverConfig,
} from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
// import { AppController } from './app.controller';
import { AppResolver } from './app.resolver';
import { AppService } from './app.service';

@Module({
  imports: [
    GraphQLModule.forRoot<ApolloFederationDriverConfig>({
      driver: ApolloFederationDriver,
      autoSchemaFile: 'src/common/graphql/schema.gql',
    }),
  ],
  // controllers: [AppController],
  providers: [
    AppResolver, //
    AppService,
  ],
})
export class AppModule {}
```

컨트롤러는 사용하지 않으니 주석 처리합니다. 

### resource

`resource` 폴더 안에 내용을 삭제하고, **auth** 폴더의 내용을 복사 붙여넣기합니다. 

`main.ts` 파일에서 포트를 `3001`로 수정합니다. 

```tsx
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3002);
}
bootstrap();
```

`app.resolver.ts` 파일에 `fetchBoards` API를 만들어줍니다. 

```tsx
// import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';
import { Resolver, Query, Mutation } from '@nestjs/graphql';

@Resolver()
export class AppResolver {
  constructor(private readonly appService: AppService) {}

  @Query(() => String)
  fetchBoards(): string {
    return 'fetchBoards를 요청하셨습니다.';
  }
}
```

### api-gateway

마지막으로 api-gateway를 수정하겠습니다.

`app.controller.ts` 파일은 삭제합니다. 

`app.module.ts` 파일을 아래와 같이 수정합니다.

`@apollo/gateway` 과 `@nestjs/apollo` , `@nestjs/graphql`, `graphql`, `apollo-server-express` 을 설치합니다. 

```tsx
import { IntrospectAndCompose } from '@apollo/gateway';
import { ApolloGatewayDriver, ApolloGatewayDriverConfig } from '@nestjs/apollo';
import { GraphQLModule } from '@nestjs/graphql';
import { Module } from '@nestjs/common';
// import { AppController } from './app.controller';
// import { AppService } from './app.service';

@Module({
  imports: [
    GraphQLModule.forRoot<ApolloGatewayDriverConfig>({
      driver: ApolloGatewayDriver,
      gateway: {
        supergraphSdl: new IntrospectAndCompose({
          subgraphs: [
            { name: 'auth', url: 'http://auth-service:3001/graphql' },
            { name: 'resource', url: 'http://resource-service:3002/graphql' },
          ],
        }),
      },
    }),
  ],
  // controllers: [AppController],
  // providers: [AppService],
})
export class AppModule {}
```

`Dockerfile` 과 `docker-compose.yaml`, `.dockerignore` 파일을 **33-01-msa-rest** 폴더에서 복사해옵니다. 

마찬가지로 `Dockerfile`은 각 폴더마다 하위에 넣어줍니다.

api-gateway >  `Dockerfile`

```docker
FROM node:16

WORKDIR /api-gateway/
COPY ./package.json /api-gateway/
COPY ./yarn.lock /api-gateway/
RUN yarn install

COPY . /api-gateway/
CMD yarn start:dev
```

auth >  `Dockerfile`

```docker
FROM node:16

WORKDIR /auth-service/
COPY ./package.json /auth-service/
COPY ./yarn.lock /auth-service/
RUN yarn install

COPY . /auth-service/
CMD yarn start:dev
```

auth >  `Dockerfile`

```docker
FROM node:16

WORKDIR /resource-service/
COPY ./package.json /resource-service/
COPY ./yarn.lock /resource-service/
RUN yarn install

COPY . /resource-service/
CMD yarn start:dev
```

`.dockerignore`

```tsx
dist
node_modules
```

```yaml
version: "3.3"

services:
  api-gateway:
    build:
      context: ./api-gateway
      dockerfile: Dockerfile
    volumes:
      - ./api-gateway/src:/api-gateway/src
    ports:
      - 3000:3000

  auth-service:
    build:
      context: ./services/auth
      dockerfile: Dockerfile
    volumes:
      - ./services/auth/src:/auth-service/src
    ports:
      - 3001:3001

  resource-service:
    build:
      context: ./services/resource
      dockerfile: Dockerfile
    volumes:
      - ./services/resource/src:/resource-service/src
    ports:
      - 3002:3002
```

도커를 띄우고 플레이그라운드에서 확인합니다.

![Untitled](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/Untitled%2013.png)

---

# Nginx를 API-Gateway로 하여 Main / Stock 서비스 분리

지금까지는 같은 프레임워크, 같은 API 쿼리 언어(restAPI, GraphQL)를 사용하였습니다. 그런데 만약 다른 프레임워크 다른 API 쿼리 언어를 사용했다면 어떻게 진행해야 할까요?

이때 NginX 이전에 배웠던 API-Gateway 용도로 사용하면 됩니다. 이런 방법을 NginX의 Reverse Proxy라고 합니다.  

예를 들어 해외여행을 갔다는 가정했을 때 직항 비행기가 없어 경유하여 목적지에 가야 합니다. 여기서 경유지가 Proxy가 됩니다. 즉 Proxy 서버란 중계 서버입니다.

***그럼 잠시 NginX의 Reverse Proxy에 환경 두가지를 알아보겟습니다.***

## ****Nginx Reverse Proxy****

### 순방향 Proxy(Forward Proxy)

특정 기업의 내부망 PC 혹은 서버들이 인터넷에 접속할때 먼저 Proxy 서버를 거쳐서 인터넷에 연결되는 방식입니다. 순방향 Proxy는 아래와 같이 두 가지 장점이 있습니다.

- 보안: Proxy Server에서 In/Out bound 패킷에 대한 보안 정책(Content filtering 등)을 적용할 수 있습니다.
- **성능** : Proxy Server는 내부에 Cache를 유지하며 이미 한번 통신한 외부 서버의 이미지, 파일, 그 외정보들을 저장할 수 있습니다. 내부 사용자가 원격 서버에 접속 시, **cache에 데이터가 있으면** 물리적으로 먼 곳까지 갈 필요없이 **Proxy 서버가 데이터를 제공하여 빠른 통신**을 지원합니다.

![스크린샷 2022-03-08 오전 10.12.18.png](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-03-08_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.12.18.png)

### 역방향 Proxy (Reverse Proxy)

**외부에서 내부 서버가 제공하는 서비스 접근** 시, Proxy 서버를 먼저 거쳐서 내부 서버로 들어오는 방식입니다.

Reverse Proxy 사용으로 얻는 장점은 크게 아래와 같습니다.

- **보안** : 외부 사용자는 실제 내부망에 있는 서버의 존재를 모르게 됩니다. 모든 접속은 Reverse Proxy 서버에게 들어오며, Reverse Proxy는 요청에 맵핑되는 내부 서버의 정보를 알고 요청을 넘겨줍니다. 따라서 내부 서버의 정보를 외부로부터 숨길 수 있습니다.

- **로드밸런싱** : Proxy 서버가 내부 서버의 정보를 알고 있으므로 로드밸런싱을 통해 부하 여부에 따라 요청을 분배 할 수 있습니다.

![스크린샷 2022-03-08 오전 10.14.56.png](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-03-08_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.14.56.png)

***실습을 통해 NginX의 역방향 Proxy를 적용(API-Gateway) 해서 Micro Service 구조를 진행해 보겠습니다.***

먼저 class 폴더 안에서 `33-03-msa-nginx` 폴더를 만들어 주세요.

![스크린샷 2022-03-08 오전 10.19.12.png](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-03-08_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.19.12.png)

sercives ⇒ auth : NestJS + GQL 프로젝트

services ⇒ stock : NodeJS + Rest API 프로젝트

폴더 내부는 다음과 같습니다. 다음과 같이 폴더를 구성해서 각 디렉토리에 프로젝트를 만들어주세요.

![스크린샷 2022-03-08 오전 10.23.25.png](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-03-08_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.23.25.png)

`auth` 프로젝트 내부 디렉터리는 다음과 같습니다. 터미널에 `nest new auth` 명령어를 사용해서 Nestjs 프로젝트를 생성하는 거 잊지 않으셨죠? 이쯤 되면 이 정도는 외우셔야 합니다.

![resolver.png](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/resolver.png)

간단하게 라우팅을 핸들링할 resolver를 `app.resolver.ts`에 만들어주세요.

![main.png](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/main.png)

`main.ts`에 NestJS의 listen port 번호는 3001로 지정했습니다.

```docker
FROM node:16

WORKDIR /auth-service/
COPY ./package.json /auth-service/
COPY ./yarn.lock /auth-service/
RUN yarn install

COPY . /auth-service/
CMD yarn dev
```

`NodeJS`의 `Docker파일`은 다음과 같습니다. 추가해주세요.

![스크린샷 2022-03-08 오전 10.31.25.png](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-03-08_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.31.25.png)

stock 프로젝트의 내부 디렉터리 구성은 다음과 같습니다. NodeJS 프로젝트를 생성할 때 먼저 `index.js` 파일을 만들고 `yarn init` 명령어를 입력해서 `package.json` 파일을 만드는 거 기억하시죠? 기억하셔야 합니다.

```json
{
  "name": "01-02-class-with-OOP-express",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT",
  "type": "module",
  "scripts": {
    "dev": "node index.js"
  },
  "dependencies": {
    "express": "^4.17.2"
  }
}
```

`package.json`은 다음과 같습니다. 직접 필요한 모듈을 설치하셔도 됩니다.

![index.png](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/index.png)

간단하게 API를 다음과 같이 만들어주세요. `NodeJS`의 listen port는 3002로 지정해 주었습니다.

```docker
FROM node:16

WORKDIR /stock-service/
COPY ./package.json /stock-service/
COPY ./yarn.lock /stock-service/
RUN yarn install

COPY . /stock-service/
CMD yarn dev
```

`NestJS` 의 `Docker파일`은 다음과 같습니다. 추가해주세요.

![스크린샷 2022-03-08 오전 10.41.19.png](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-03-08_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.41.19.png)

이제 `NginX`의 `.conf파일`을 만들어주겠습니다. `Nginx`가 **역방향 Proxy를 진행할수 있도록 설정해줄 겁니다.**

```
#default.conf

server {
    listen 80;

    location /graphql {
        proxy_pass http://auth-service:3001;
    }

    location /stocks {
        proxy_pass http://stock-service:3002;
    }
}
```

**NginX의 default port 번호는 80**입니다. 따라서 port 번호 80번으로 요청이 왔을 때 `/` 기준으로 graphql이 뒤에 붙으면 `NestJS + GQL 프로젝트`로 **GraphQL** 요청을 보내고 stock이 붙으면 `NodeJS + Rest API 프로젝트`로 **RestAPI**으로 **요청을 보내는 중계서버 역할을 하는 설정입니다.**

![스크린샷 2022-03-08 오전 10.50.27.png](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-03-08_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.50.27.png)

```yaml
#docker-compose.yaml

version: "3.3"

services:
  api-gateway:
    image: nginx:latest
    volumes:
      - ./api-gateway/default.conf:/etc/nginx/conf.d/default.conf
    ports:
      - 80:80

  auth-service:
    build:
      context: ./services/auth
      dockerfile: Dockerfile
    volumes:
      - ./services/auth/src:/auth-service/src
    ports:
      - 3001:3001

  stock-service:
    build:
      context: ./services/stock
      dockerfile: Dockerfile
    volumes:
      - ./services/stock/src:/stock-service/src
    ports:
      - 3002:3002
```

`docker-compose.yaml 파일`을 `33-03-msa-nginx` 디렉터리 안에 만들어주시고 다음과 같이 내용을 작성해 주세요.

![스크린샷 2022-03-08 오전 10.52.31.png](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-03-08_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.52.31.png)

`docker compose build` `docker compose up` 을 입력해서 이미지를 빌드해 주시고 서버를 실행해 주세요.

![스크린샷 2022-03-08 오전 10.57.43.png](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-03-08_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.57.43.png)

`POSTMAN`을 실행해서 GET<[localhost/stocks>로](http://localhost:80/stocks로) 요청을 보내보니 `RestAPI`가 정상적으로 작동합니다.

![스크린샷 2022-03-08 오전 10.55.53.png](BE%20Day31%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20NginX%202ec88403ecaa45fa9785a1af564800b2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-03-08_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.55.53.png)

브라우저를 열어서 [http://localhost/graphql](http://localhost/graphql) 들어가주세요. `playground`도 잘 실행되며, `docs`도 정상적으로 등록되었습니다.